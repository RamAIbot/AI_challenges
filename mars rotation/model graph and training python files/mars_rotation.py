# -*- coding: utf-8 -*-
"""mars_rotation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U7-Edmu6X3-2lp3KGz1NiVHY-66i8vAZ
"""

import torch
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import torchvision

from google.colab import drive
drive.mount('/content/drive')

!cp -r '/content/drive/MyDrive/rotation_classification' '/content'

import os
try:
  os.mkdir('/content/train')
  os.mkdir('/content/val')
  os.mkdir('/content/test')
except OSError as error:
  print(error)

!cp '/content/rotation_classification/train (2).zip' '/content/train/train.zip'
!unzip '/content/train/train.zip' -d '/content/train'
!rm -f '/content/train/train.zip'

!cp '/content/rotation_classification/val (2).zip' '/content/val/val.zip'
!unzip '/content/val/val.zip' -d '/content/val'
!rm -f '/content/val/val.zip'

!cp '/content/rotation_classification/val.csv' '/content/val.csv'
!cp '/content/rotation_classification/train (1).csv' '/content/train.csv'

# from sklearn.preprocessing import OneHotEncoder
# classes = np.asarray([i for i in range(1,361)])
# enc = OneHotEncoder(sparse=False)
# enc.fit(classes.reshape(len(classes),1))

# enc.categories_[0:5]

# temp_dat = enc.transform([[360]])
# print(temp_dat)
# print(np.argmax(temp_dat)+1)

# temp_dat = enc.transform([[1]])
# print(temp_dat)
# print(np.argmax(temp_dat)+1)

train_csv = pd.read_csv('/content/train.csv')
dummy = train_csv.values
print(dummy[0:5])
dummy1 = dummy[:,1]
train_data = dummy1
print(train_data[0:5])

# print(train_data[0])
# print(np.argmax(train_data[0])+1)

val_csv = pd.read_csv('/content/val.csv')
vals = val_csv.values
vals1 = vals[:,1]
val_data = vals1
print(val_data[0:5])

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
print(device)

from torch.utils.data import Dataset, DataLoader
from torchvision import transforms, utils
import cv2
from PIL import Image 


class rotationclass(Dataset):

  def __init__(self,csv_data,root_dir,transform=None):
    self.root_dir = root_dir
    self.transform = transform
    self.data = csv_data

  def __len__(self):
    return len(self.data)

  def __getitem__(self,idx):
    img_path = self.root_dir +'/'+ str(idx) + '.jpg'
    image = Image.open(img_path)
    label = int(self.data[idx])
    
    if self.transform:
      tensor_image = self.transform(image)

    return tensor_image,label

import torchvision.models as models
resnet18 = models.resnet18()
resnet18

resnet18.fc = torch.nn.Linear(512,360)
resnet18

resnet18 = resnet18.to(device)

batch_size = 32
train_set = rotationclass(train_data,'/content/train',transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize(mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225])
                                                              ]))
train_loader = torch.utils.data.DataLoader(train_set,batch_size=batch_size,shuffle=True)

val_set = rotationclass(val_data,'/content/val',transforms.Compose([
          transforms.ToTensor(),
          transforms.Normalize(mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225]),
                                                                 ]))
val_loader = torch.utils.data.DataLoader(val_set,batch_size=batch_size,shuffle=False)

def evaluation(dataloader):
  total,correct = 0,0
  for data in dataloader:
    inputs,labels = data
    inputs,labels = inputs.to(device),labels.to(device)
    outputs = resnet18(inputs)
    _,pred = torch.max(outputs.data,1) 
    pred = pred + 1
    total += labels.size(0)
    correct += (pred==labels).sum().item()
  
  return 100*correct/total

import torch.optim as optim
import torch.nn as nn
loss_fn = nn.CrossEntropyLoss()
opt = optim.Adam(resnet18.parameters())

from tqdm import tqdm
loss_arr = []
loss_epoch_arr = []
max_epochs = 10

for epoch in tqdm(range(max_epochs)):
  for i, data in enumerate(train_loader,0):
    inputs, labels = data
    inputs,labels = inputs.to(device),labels.to(device)
    opt.zero_grad()

    outputs = resnet18(inputs)
    #print(outputs.shape)
    #_,pred_labels = torch.max(outputs.data,1)
    #pred_labels = pred_labels + 1
    #print(pred_labels)
    #print(labels)
    loss = loss_fn(outputs,labels-1)
    loss.backward()
    opt.step()

    loss_arr.append(loss.item())

  PATH = '/content/' + 'model_' + str(epoch) + '.pt'
  
  
  loss_epoch_arr.append(loss.item())

  print('Epoch = %d/%d, Val Acc: %0.2f, Train Acc: %0.2f '%(epoch,max_epochs,
        evaluation(val_loader),evaluation(train_loader)))
  torch.save({
            'epoch': epoch,
            'model_state_dict': resnet18.state_dict(),
            'optimizer_state_dict': opt.state_dict(),
            'loss': loss.item(),
            }, PATH)

plt.plot(loss_epoch_arr)
plt.show()

new_model = models.resnet18()
new_model.fc = torch.nn.Linear(512,360)
checkpoint = torch.load('/content/model_6.pt')
new_model.load_state_dict(checkpoint['model_state_dict'])
opt.load_state_dict(checkpoint['optimizer_state_dict'])
epoch = checkpoint['epoch']
loss = checkpoint['loss']
new_model.eval()

!cp '/content/rotation_classification/test (1).zip' '/content/test/test.zip'
!unzip '/content/test/test.zip' -d '/content/test'
!rm -f '/content/test/test.zip'

import os
test_images = os.listdir('/content/test')
print(test_images[0:5])

transformation = transforms.Compose([
          transforms.ToTensor(),
          transforms.Normalize(mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225]),
                                                                 ])

out_final = []
new_model = new_model.to(device)
# curiosity = 0
# perseverance = 1
for images in tqdm(test_images):
  index = images.split('.')[0]
  img_path = '/content/test/'+ images
  image = Image.open(img_path)
  #image = np.expand_dims(image,axis=0)
  image = transformation(image)
  #image = transforms.Normalize(image,mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225])
  image = image.unsqueeze(0)
  image = image.to(device)
  out = new_model(image)
  _,pred = torch.max(out.data,1)
  angle = pred.item()
  angle = angle + 1
  arr = [int(index),angle]
  out_final.append(arr)

print(out_final[0:5])

dataset = pd.DataFrame(out_final,columns=['ImageID','label'])
dataset.head()

dataset.to_csv('output_mars_angle_classification.csv',index=False)