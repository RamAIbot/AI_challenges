# -*- coding: utf-8 -*-
"""rover_classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kBHI0nHeLaBY_wfRJ_swKclP4ehEvmx-
"""

import torch
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import torchvision

from google.colab import drive
drive.mount('/content/drive')

!cp -r '/content/drive/MyDrive/rover_classification/' '/content'

import os
try:
  os.mkdir('/content/train')
  os.mkdir('/content/val')
  os.mkdir('/content/test')
except OSError as error:
  print(error)

!cp '/content/rover_classification/train (2).zip' '/content/train/train.zip'
!unzip '/content/train/train.zip' -d '/content/train'
!rm -f '/content/train/train.zip'

!cp '/content/rover_classification/val (2).zip' '/content/val/val.zip'
!unzip '/content/val/val.zip' -d '/content/val'
!rm -f '/content/val/val.zip'

!cp '/content/rover_classification/val.csv' '/content/val.csv'
!cp '/content/rover_classification/train (1).csv' '/content/train.csv'

from sklearn.preprocessing import LabelEncoder
train_csv = pd.read_csv('/content/train.csv')
dummy = train_csv.values
enc = LabelEncoder()
train_data = enc.fit_transform(dummy[:,1])
print(train_data[0:5])

val_csv = pd.read_csv('/content/val.csv')
vals = val_csv.values
val_data = enc.transform(vals[:,1])
print(val_data[0:5])

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
print(device)

from torch.utils.data import Dataset, DataLoader
from torchvision import transforms, utils
import cv2
from PIL import Image 


class roverclass(Dataset):

  def __init__(self,csv_data,root_dir,transform=None):
    self.root_dir = root_dir
    self.transform = transform
    self.data = csv_data

  def __len__(self):
    return len(self.data)

  def __getitem__(self,idx):
    img_path = self.root_dir +'/'+ str(idx) + '.jpg'
    image = Image.open(img_path)
    label = int(self.data[idx])
    
    if self.transform:
      tensor_image = self.transform(image)

    return tensor_image,label

r = roverclass(train_data,'/content/train',transforms.Compose([transforms.ToTensor(),
               transforms.Normalize(mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225])]))
#img = r.__getitem__(3)[0]
lab = r.__getitem__(3)[1]
print(lab)
#plt.imshow(img)
#plt.show()
print(r.__getitem__(3)[0])

import torchvision.models as models
resnet18 = models.resnet18()
resnet18 = resnet18.to(device)

batch_size = 32
train_set = roverclass(train_data,'/content/train',transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize(mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225])
                                                              ]))
train_loader = torch.utils.data.DataLoader(train_set,batch_size=batch_size,shuffle=True)

val_set = roverclass(val_data,'/content/val',transforms.Compose([
          transforms.ToTensor(),
          transforms.Normalize(mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225]),
                                                                 ]))
val_loader = torch.utils.data.DataLoader(val_set,batch_size=batch_size,shuffle=False)

def evaluation(dataloader):
  total,correct = 0,0
  for data in dataloader:
    inputs,labels = data
    inputs,labels = inputs.to(device),labels.to(device)
    outputs = resnet18(inputs)
    _,pred = torch.max(outputs.data,1)
    total += labels.size(0)
    correct += (pred==labels).sum().item()
  
  return 100*correct/total

import torch.optim as optim
import torch.nn as nn
loss_fn = nn.CrossEntropyLoss()
opt = optim.Adam(resnet18.parameters())

from tqdm import tqdm
loss_arr = []
loss_epoch_arr = []
max_epochs = 16

for epoch in tqdm(range(max_epochs)):
  for i, data in enumerate(train_loader,0):
    inputs, labels = data
    inputs,labels = inputs.to(device),labels.to(device)
    opt.zero_grad()

    outputs = resnet18(inputs)
    loss = loss_fn(outputs,labels)
    loss.backward()
    opt.step()

    loss_arr.append(loss.item())
  
  loss_epoch_arr.append(loss.item())

  print('Epoch = %d/%d, Val Acc: %0.2f, Train Acc: %0.2f '%(epoch,max_epochs,
        evaluation(val_loader),evaluation(train_loader)))
  

plt.plot(loss_epoch_arr)
plt.show()

torch.save(resnet18.state_dict(),'./model_rover_classification.pth')

new_model = models.resnet18()
new_model.load_state_dict(torch.load('/content/model_rover_classification.pth'))

!cp '/content/rover_classification/test.zip' '/content/test/test.zip'
!unzip '/content/test/test.zip' -d '/content/test'
!rm -f '/content/test/test.zip'

import os
test_images = os.listdir('/content/test')
print(test_images[0:5])

transformation = transforms.Compose([
          transforms.ToTensor(),
          transforms.Normalize(mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225]),
                                                                 ])

from tqdm import tqdm
out_final = []
new_model = new_model.to(device)
# curiosity = 0
# perseverance = 1
for images in tqdm(test_images):
  index = images.split('.')[0]
  img_path = '/content/test/'+ images
  image = Image.open(img_path)
  #image = np.expand_dims(image,axis=0)
  image = transformation(image)
  #image = transforms.Normalize(image,mean=[0.485, 0.456, 0.406],std=[0.229, 0.224, 0.225])
  image = image.unsqueeze(0)
  image = image.to(device)
  out = new_model(image)
  _,pred = torch.max(out.data,1)
  rover = ''
  if pred.item() == 0:
    rover = 'curiosity'
  else:
    rover = 'perseverance'

  arr = [int(index),rover]
  out_final.append(arr)

print(out_final[0:5])

print(out_final[0:5])

dataset = pd.DataFrame(out_final,columns=['ImageID','label'])
dataset.head()

dataset.to_csv('output_rover_classification_new.csv',index=False)

from pickle import dump
dump(enc, open('labelencoder.pkl', 'wb'))

from pickle import load
scaler = load(open('labelencoder.pkl', 'rb'))